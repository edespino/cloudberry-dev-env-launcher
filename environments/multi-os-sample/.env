# Enhanced .env with optimizations for environments/ol810-test
# Loaded by zsh dotenv plugin for helpful aliases

# =============================================================================
# SPOT INSTANCE AVAILABILITY CHECKER (sourced from shared library)
# =============================================================================

# Source shared spot checking functions
REPO_ROOT="$(cd ../.. && pwd)"
if [[ -f "$REPO_ROOT/lib/spot-functions.sh" ]]; then
    source "$REPO_ROOT/lib/spot-functions.sh"
else
    echo "‚ö†Ô∏è  Warning: Shared spot functions not found at $REPO_ROOT/lib/spot-functions.sh" >&2
fi

# Functions are now loaded from shared library above

# =============================================================================
# CORE FUNCTIONS (Optimizations 1, 4)
# =============================================================================

# IP lookup function (excludes terminated instances explicitly)
get_instance_ip() {
  local instance_index="${1:-0}"
  
  # Fetch IP directly, explicitly excluding terminated instances
  local ip=$(aws ec2 describe-instances --region "$TF_VAR_region" \
    --filters "Name=tag:Name,Values=${TF_VAR_env_prefix}-instance-${instance_index}" \
              "Name=instance-state-name,Values=running" \
    --query "Reservations[*].Instances[*].PublicIpAddress" \
    --output text 2>/dev/null | head -n1)
  
  if [[ -n "$ip" && "$ip" != "None" && "$ip" != "" ]]; then
    echo "$ip"
  else
    echo "‚ùå No running instance found for ${TF_VAR_env_prefix}-instance-${instance_index}" >&2
    return 1
  fi
}

# Function to safely clean IP cache files
clean_ip_cache() {
  setopt NULL_GLOB 2>/dev/null || true
  rm -f /tmp/${TF_VAR_env_prefix}_ip_* 2>/dev/null || true
  unsetopt NULL_GLOB 2>/dev/null || true
}

# Enhanced function to retrieve the public IP and wait for SSH availability
wait_for_ssh() {
  local region="$1"
  local env_prefix="$2"
  local instance_index="${3:-0}"
  local hostname

  # Retrieve the IP address using cached function
  hostname=$(get_instance_ip "$instance_index")

  if [ -z "$hostname" ] || [ "$hostname" = "None" ]; then
    echo "‚ùå Failed to retrieve IP address for ${env_prefix}-instance-${instance_index} in region ${region}."
    return 1
  fi

  echo "‚è≥ Waiting for SSH to become available on ${hostname}..."

  for ((i=1; i<=30; i++)); do
    if timeout 5 nc -z "$hostname" 22 2>/dev/null; then
      echo "‚úÖ SSH is available on ${hostname}"
      break
    else
      echo "‚è≥ SSH not ready (attempt $i/30). Retrying..."
      sleep $((i*2))
    fi

    if [ $i -eq 30 ]; then
      echo "‚ùå SSH is still not available after 30 attempts. Exiting."
      rename_ami "FAILED"
      cleanup
      exit 1
    fi
  done
}

# SSH connection options with timeouts (as array for proper expansion)
SSH_OPTS=(-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10 -o LogLevel=ERROR)

# NOTE: SSH key path is set in .envrc
## SSH_KEY_PATH="${TF_VAR_env_prefix}_generated_key.pem"

# =============================================================================
# SSH ALIASES (Optimizations 2, 8) - DRY User Alias Generator
# =============================================================================

# Function to create user-specific SSH and file transfer aliases
# Usage: create_user_ssh_aliases <username> <ssh_prefix> <wait_prefix>
create_user_ssh_aliases() {
  local username="$1"
  local ssh_prefix="$2"      # e.g., "lc" for cbadmin, "lg" for gpadmin
  local wait_prefix="$3"     # e.g., "lcw" for cbadmin, "lgw" for gpadmin

  # Wait and copy SSH key to user
  alias ${wait_prefix}='wait_for_ssh ${TF_VAR_region} ${TF_VAR_env_prefix}; \
             ssh "${SSH_OPTS[@]}" \
                 -i ${SSH_KEY_PATH} \
                 ${TF_VAR_default_username}@$(get_instance_ip 0) \
                 "cat ~/.ssh/authorized_keys | sudo tee -a ~'$username'/.ssh/authorized_keys > /dev/null" && \
             echo "‚úÖ SSH key copied to '$username' user"'

  # SSH connections for 3 instances
  alias ${ssh_prefix}ssh='ssh "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} '$username'@$(get_instance_ip 0) -A'
  alias ${ssh_prefix}ssh1='ssh "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} '$username'@$(get_instance_ip 1) -A'
  alias ${ssh_prefix}ssh2='ssh "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} '$username'@$(get_instance_ip 2) -A'

  # File transfer - copy to
  alias ${ssh_prefix}copyto='function _'${ssh_prefix}'copyto() {
    echo "üì§ Copying $1 to '$username'@$(get_instance_ip 0):$2"
    scp "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} "$1" '$username'@$(get_instance_ip 0):"$2"
  }; _'${ssh_prefix}'copyto'

  # File transfer - copy from
  alias ${ssh_prefix}copyfrom='function _'${ssh_prefix}'copyfrom() {
    echo "üì• Copying '$username'@$(get_instance_ip 0):$1 to $2"
    scp "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} '$username'@$(get_instance_ip 0):"$1" "$2"
  }; _'${ssh_prefix}'copyfrom'
}

# Wait for SSH (enhanced with multi-instance support)
alias lw='wait_for_ssh ${TF_VAR_region} ${TF_VAR_env_prefix}'
alias lw1='wait_for_ssh ${TF_VAR_region} ${TF_VAR_env_prefix} 1'
alias lw2='wait_for_ssh ${TF_VAR_region} ${TF_VAR_env_prefix} 2'

# Default user SSH connections (using cached IPs and timeouts)
alias lssh='ssh "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} ${TF_VAR_default_username}@$(get_instance_ip 0) -A'
alias lssh1='ssh "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} ${TF_VAR_default_username}@$(get_instance_ip 1) -A'
alias lssh2='ssh "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} ${TF_VAR_default_username}@$(get_instance_ip 2) -A'

# Create cbadmin aliases (backward compatible: lcssh, lcw, lccopyto, etc.)
create_user_ssh_aliases "cbadmin" "lc" "lcw"

# Create gpadmin aliases (new: lgssh, lgw, lgcopyto, etc.)
create_user_ssh_aliases "gpadmin" "lg" "lgw"

# =============================================================================
# INSTANCE MANAGEMENT (Optimization 3)
# =============================================================================

# Instance state with enhanced output (excluding terminated instances)
alias istate='aws ec2 describe-instances --region "$TF_VAR_region" \
  --filters "Name=tag:Name,Values=${TF_VAR_env_prefix}-instance-*" \
            "Name=instance-state-name,Values=pending,running,shutting-down,stopping,stopped" \
  --query "Reservations[].Instances[].[Tags[?Key==\`Name\`].Value|[0], State.Name, InstanceType, PublicIpAddress, PrivateIpAddress]" \
  --output table'

# All non-terminated instances across the project
alias iastate='aws ec2 describe-instances --region "$TF_VAR_region" \
  --filters "Name=instance-state-name,Values=pending,running,shutting-down,stopping,stopped" \
  --query "Reservations[].Instances[].[Tags[?Key==\`Name\`].Value|[0], State.Name, InstanceType, PublicIpAddress, PrivateIpAddress]" \
  --output table'

# Instance start with cache invalidation
alias istart='echo "üöÄ Starting instances..." && \
  STOPPED_IDS=$(aws ec2 describe-instances --region "$TF_VAR_region" \
    --filters "Name=tag:Name,Values=${TF_VAR_env_prefix}-instance-*" "Name=instance-state-name,Values=stopped" \
    --query "Reservations[].Instances[].InstanceId" --output text) && \
  if [[ -n "$STOPPED_IDS" ]]; then \
    aws ec2 start-instances --region "$TF_VAR_region" --instance-ids $STOPPED_IDS && \
    echo "‚è≥ Waiting for instances to be running..." && \
    aws ec2 wait instance-running --region "$TF_VAR_region" --instance-ids $STOPPED_IDS && \
    echo "‚úÖ Instances are now running"; \
  else \
    echo "‚ÑπÔ∏è  No stopped instances found to start"; \
  fi; \
  clean_ip_cache'

# Instance stop with cache invalidation
alias istop='echo "üõë Stopping instances..." && \
  RUNNING_IDS=$(aws ec2 describe-instances --region "$TF_VAR_region" \
    --filters "Name=tag:Name,Values=${TF_VAR_env_prefix}-instance-*" "Name=instance-state-name,Values=running" \
    --query "Reservations[].Instances[].InstanceId" --output text) && \
  if [[ -n "$RUNNING_IDS" ]]; then \
    aws ec2 stop-instances --region "$TF_VAR_region" --no-hibernate --instance-ids $RUNNING_IDS && \
    echo "‚è≥ Waiting for instances to stop..." && \
    aws ec2 wait instance-stopped --region "$TF_VAR_region" --instance-ids $RUNNING_IDS && \
    echo "‚úÖ Instances are now stopped"; \
  else \
    echo "‚ÑπÔ∏è  No running instances found to stop"; \
  fi; \
  clean_ip_cache'

# Refresh with cache invalidation
alias irefresh='clean_ip_cache && echo "‚úÖ IP cache refreshed"'

# =============================================================================
# FILE TRANSFER (Optimization 6)
# =============================================================================
# Note: User-specific file transfer aliases (lccopyto, lccopyfrom, lgcopyto, lgcopyfrom)
# are now created by create_user_ssh_aliases() function above

# Default user file transfer aliases with progress feedback
alias lcopyto='function _lcopyto() {
  echo "üì§ Copying $1 to ${TF_VAR_default_username}@$(get_instance_ip 0):$2"
  scp "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} "$1" ${TF_VAR_default_username}@$(get_instance_ip 0):"$2"
}; _lcopyto'

alias lcopyfrom='function _lcopyfrom() {
  echo "üì• Copying ${TF_VAR_default_username}@$(get_instance_ip 0):$1 to $2"
  scp "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} ${TF_VAR_default_username}@$(get_instance_ip 0):"$1" "$2"
}; _lcopyfrom'

# Multi-instance SCP for default user
alias lcopyto1='function _lcopyto1() {
  echo "üì§ Copying $1 to ${TF_VAR_default_username}@$(get_instance_ip 1):$2"
  scp "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} "$1" ${TF_VAR_default_username}@$(get_instance_ip 1):"$2"
}; _lcopyto1'

alias lcopyto2='function _lcopyto2() {
  echo "üì§ Copying $1 to ${TF_VAR_default_username}@$(get_instance_ip 2):$2"
  scp "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} "$1" ${TF_VAR_default_username}@$(get_instance_ip 2):"$2"
}; _lcopyto2'

# =============================================================================
# STATUS & MONITORING (Optimization 5) - DRY User Monitoring Generator
# =============================================================================

# Function to create user-specific monitoring aliases
# Usage: create_user_monitoring_aliases <username> <prefix>
create_user_monitoring_aliases() {
  local username="$1"
  local prefix="$2"  # Empty for cbadmin (backward compatible), "g" for gpadmin

  # Logs - follow system journal
  alias ${prefix}logs='ssh "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} '$username'@$(get_instance_ip 0) "sudo journalctl -f"'

  # Top - system resource monitoring
  alias ${prefix}top='ssh "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} '$username'@$(get_instance_ip 0) "htop"'

  # Disk - disk usage and block devices
  alias ${prefix}disk='ssh "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} '$username'@$(get_instance_ip 0) "df -h && echo && lsblk"'
}

# Status and monitoring shortcuts (generic, not user-specific)
alias istatus='echo "üìä ${TF_VAR_env_prefix} Status:" && istate'

alias iping='for i in {0..2}; do
  echo "üèì Pinging instance-$i:"
  timeout 3 ping -c 2 $(get_instance_ip $i) 2>/dev/null || echo "‚ùå Instance $i not reachable"
done'

# Create cbadmin monitoring aliases (backward compatible: ilogs, itop, idisk)
create_user_monitoring_aliases "cbadmin" "i"

# Create gpadmin monitoring aliases (new: glogs, gtop, gdisk)
create_user_monitoring_aliases "gpadmin" "g"

# =============================================================================
# VS CODE & DEVELOPMENT - DRY User VS Code Generator
# =============================================================================

# Function to create user-specific VS Code aliases
# Usage: create_user_vscode_aliases <username> <prefix>
create_user_vscode_aliases() {
  local username="$1"
  local prefix="$2"  # Empty for cbadmin (backward compatible), "g" for gpadmin

  # VS Code remote with error handling
  alias ${prefix}code='function _'${prefix}'code() {
    local path="${1:-/home/'$username'}"
    local hostname=$(get_instance_ip 0)
    if [[ -n "$hostname" && "$hostname" != "None" ]]; then
      echo "üîó Opening VS Code remote to ${hostname}:${path}"
      /Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin/code --remote "ssh-remote+${TF_VAR_env_prefix}" "$path"
    else
      echo "‚ùå Cannot connect - instance not running"
      return 1
    fi
  }; _'${prefix}'code'

  # Shortcut for cloudberry directory
  alias ${prefix}cloudberry="${prefix}code /home/$username/cloudberry"
}

# Create cbadmin VS Code aliases (backward compatible: icode, icloudberry)
create_user_vscode_aliases "cbadmin" "i"

# Create gpadmin VS Code aliases (new: gcode, gcloudberry)
create_user_vscode_aliases "gpadmin" "g"

# =============================================================================
# UTILITY ALIASES
# =============================================================================

# Network and AWS utilities
alias myip='echo $(curl -s https://api.ipify.org)'
alias isso='aws sso login --sso-session your-sso-session'

# Spot instance availability checker aliases
alias spot-check='check_spot_availability'
alias spot-prices='check_spot_prices'

# Justfile integration (update path as needed)
alias j='just -f /home/cbadmin/cloudberry-devenv-launcher/docs/Justfile'

# Performance testing
alias itest='echo "üß™ Running performance tests..." && ./performance-test.sh'

# Environment info
alias iinfo='echo "üè∑Ô∏è  Environment: $TF_VAR_env_prefix" && 
echo "üåç Region: $TF_VAR_region" && 
echo "üë§ User: $TF_VAR_default_username" && 
echo "üÜî AMI: $TF_VAR_ami" && 
echo "üíª Instance Type: $TF_VAR_instance_type" && 
echo "üî¢ VM Count: $TF_VAR_vm_count"'

# OS version check
unalias ios 2>/dev/null || true
ios() {
    ssh "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} ${TF_VAR_default_username}@$(get_instance_ip 0) 'if [ -f /etc/os-release ]; then source /etc/os-release && echo $PRETTY_NAME; else cat /proc/version | sed "s/Linux version //" | cut -d" " -f1-2; fi' 2>/dev/null
}

# Terraform init aliases
alias ti='terraform init'      # Local backend (uses backend.tf config)
