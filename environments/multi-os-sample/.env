# Enhanced .env with optimizations for environments/ol810-test
# Loaded by zsh dotenv plugin for helpful aliases

# =============================================================================
# SPOT INSTANCE AVAILABILITY CHECKER (sourced from shared library)
# =============================================================================

# Source shared spot checking functions
REPO_ROOT="$(cd ../.. && pwd)"
if [[ -f "$REPO_ROOT/lib/spot-functions.sh" ]]; then
    source "$REPO_ROOT/lib/spot-functions.sh"
else
    echo "‚ö†Ô∏è  Warning: Shared spot functions not found at $REPO_ROOT/lib/spot-functions.sh" >&2
fi

# Functions are now loaded from shared library above

# =============================================================================
# CORE FUNCTIONS (Optimizations 1, 4)
# =============================================================================

# IP lookup function (excludes terminated instances explicitly)
get_instance_ip() {
  local instance_index="${1:-0}"
  
  # Fetch IP directly, explicitly excluding terminated instances
  local ip=$(aws ec2 describe-instances --region "$TF_VAR_region" \
    --filters "Name=tag:Name,Values=${TF_VAR_env_prefix}-instance-${instance_index}" \
              "Name=instance-state-name,Values=running" \
    --query "Reservations[*].Instances[*].PublicIpAddress" \
    --output text 2>/dev/null | head -n1)
  
  if [[ -n "$ip" && "$ip" != "None" && "$ip" != "" ]]; then
    echo "$ip"
  else
    echo "‚ùå No running instance found for ${TF_VAR_env_prefix}-instance-${instance_index}" >&2
    return 1
  fi
}

# Function to safely clean IP cache files
clean_ip_cache() {
  setopt NULL_GLOB 2>/dev/null || true
  rm -f /tmp/${TF_VAR_env_prefix}_ip_* 2>/dev/null || true
  unsetopt NULL_GLOB 2>/dev/null || true
}

# Enhanced function to retrieve the public IP and wait for SSH availability
wait_for_ssh() {
  local region="$1"
  local env_prefix="$2"
  local instance_index="${3:-0}"
  local hostname

  # Retrieve the IP address using cached function
  hostname=$(get_instance_ip "$instance_index")

  if [ -z "$hostname" ] || [ "$hostname" = "None" ]; then
    echo "‚ùå Failed to retrieve IP address for ${env_prefix}-instance-${instance_index} in region ${region}."
    return 1
  fi

  echo "‚è≥ Waiting for SSH to become available on ${hostname}..."

  for ((i=1; i<=30; i++)); do
    if timeout 5 nc -z "$hostname" 22 2>/dev/null; then
      echo "‚úÖ SSH is available on ${hostname}"
      break
    else
      echo "‚è≥ SSH not ready (attempt $i/30). Retrying..."
      sleep $((i*2))
    fi

    if [ $i -eq 30 ]; then
      echo "‚ùå SSH is still not available after 30 attempts. Exiting."
      rename_ami "FAILED"
      cleanup
      exit 1
    fi
  done
}

# SSH connection options with timeouts (as array for proper expansion)
SSH_OPTS=(-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10)

# NOTE: SSH key path is set in .envrc
## SSH_KEY_PATH="${TF_VAR_env_prefix}_generated_key.pem"

# =============================================================================
# SSH ALIASES (Optimizations 2, 8)
# =============================================================================

# Wait for SSH (enhanced with multi-instance support)
alias lw='wait_for_ssh ${TF_VAR_region} ${TF_VAR_env_prefix}'
alias lw1='wait_for_ssh ${TF_VAR_region} ${TF_VAR_env_prefix} 1'
alias lw2='wait_for_ssh ${TF_VAR_region} ${TF_VAR_env_prefix} 2'

# SSH with gpadmin setup (fixed consistency issue)
alias lgw='wait_for_ssh ${TF_VAR_region} ${TF_VAR_env_prefix}; \
           ssh "${SSH_OPTS[@]}" \
               -i ${SSH_KEY_PATH} \
               ${TF_VAR_default_username}@$(get_instance_ip 0) \
               "cat ~/.ssh/authorized_keys | sudo tee -a ~gpadmin/.ssh/authorized_keys" && \
           echo "‚úÖ SSH key copied to gpadmin user"'

# SSH connections (using cached IPs and timeouts)
alias lssh='ssh "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} ${TF_VAR_default_username}@$(get_instance_ip 0) -A'
alias lssh1='ssh "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} ${TF_VAR_default_username}@$(get_instance_ip 1) -A'
alias lssh2='ssh "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} ${TF_VAR_default_username}@$(get_instance_ip 2) -A'

alias lgssh='ssh "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} gpadmin@$(get_instance_ip 0) -A'
alias lgssh1='ssh "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} gpadmin@$(get_instance_ip 1) -A'
alias lgssh2='ssh "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} gpadmin@$(get_instance_ip 2) -A'

# =============================================================================
# INSTANCE MANAGEMENT (Optimization 3)
# =============================================================================

# Instance state with enhanced output (excluding terminated instances)
alias istate='aws ec2 describe-instances --region "$TF_VAR_region" \
  --filters "Name=tag:Name,Values=${TF_VAR_env_prefix}-instance-*" \
            "Name=instance-state-name,Values=pending,running,shutting-down,stopping,stopped" \
  --query "Reservations[].Instances[].[Tags[?Key==\`Name\`].Value|[0], State.Name, InstanceType, PublicIpAddress, PrivateIpAddress]" \
  --output table'

# All non-terminated instances across the project
alias iastate='aws ec2 describe-instances --region "$TF_VAR_region" \
  --filters "Name=instance-state-name,Values=pending,running,shutting-down,stopping,stopped" \
  --query "Reservations[].Instances[].[Tags[?Key==\`Name\`].Value|[0], State.Name, InstanceType, PublicIpAddress, PrivateIpAddress]" \
  --output table'

# Instance start with cache invalidation
alias istart='echo "üöÄ Starting instances..." && \
  STOPPED_IDS=$(aws ec2 describe-instances --region "$TF_VAR_region" \
    --filters "Name=tag:Name,Values=${TF_VAR_env_prefix}-instance-*" "Name=instance-state-name,Values=stopped" \
    --query "Reservations[].Instances[].InstanceId" --output text) && \
  if [[ -n "$STOPPED_IDS" ]]; then \
    aws ec2 start-instances --region "$TF_VAR_region" --instance-ids $STOPPED_IDS && \
    echo "‚è≥ Waiting for instances to be running..." && \
    aws ec2 wait instance-running --region "$TF_VAR_region" --instance-ids $STOPPED_IDS && \
    echo "‚úÖ Instances are now running"; \
  else \
    echo "‚ÑπÔ∏è  No stopped instances found to start"; \
  fi; \
  clean_ip_cache'

# Instance stop with cache invalidation
alias istop='echo "üõë Stopping instances..." && \
  RUNNING_IDS=$(aws ec2 describe-instances --region "$TF_VAR_region" \
    --filters "Name=tag:Name,Values=${TF_VAR_env_prefix}-instance-*" "Name=instance-state-name,Values=running" \
    --query "Reservations[].Instances[].InstanceId" --output text) && \
  if [[ -n "$RUNNING_IDS" ]]; then \
    aws ec2 stop-instances --region "$TF_VAR_region" --no-hibernate --instance-ids $RUNNING_IDS && \
    echo "‚è≥ Waiting for instances to stop..." && \
    aws ec2 wait instance-stopped --region "$TF_VAR_region" --instance-ids $RUNNING_IDS && \
    echo "‚úÖ Instances are now stopped"; \
  else \
    echo "‚ÑπÔ∏è  No running instances found to stop"; \
  fi; \
  clean_ip_cache'

# Refresh with cache invalidation
alias irefresh='clean_ip_cache && echo "‚úÖ IP cache refreshed"'

# =============================================================================
# FILE TRANSFER (Optimization 6)
# =============================================================================

# Enhanced SCP aliases with progress feedback
alias lcopyto='function _lcopyto() { 
  echo "üì§ Copying $1 to ${TF_VAR_default_username}@$(get_instance_ip 0):$2"
  scp "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} "$1" ${TF_VAR_default_username}@$(get_instance_ip 0):"$2"
}; _lcopyto'

alias lgcopyto='function _lgcopyto() { 
  echo "üì§ Copying $1 to gpadmin@$(get_instance_ip 0):$2"
  scp "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} "$1" gpadmin@$(get_instance_ip 0):"$2"
}; _lgcopyto'

alias lcopyfrom='function _lcopyfrom() { 
  echo "üì• Copying ${TF_VAR_default_username}@$(get_instance_ip 0):$1 to $2"
  scp "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} ${TF_VAR_default_username}@$(get_instance_ip 0):"$1" "$2"
}; _lcopyfrom'

alias lgcopyfrom='function _lgcopyfrom() { 
  echo "üì• Copying gpadmin@$(get_instance_ip 0):$1 to $2"
  scp "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} gpadmin@$(get_instance_ip 0):"$1" "$2"
}; _lgcopyfrom'

# Multi-instance SCP
alias lcopyto1='function _lcopyto1() { 
  echo "üì§ Copying $1 to ${TF_VAR_default_username}@$(get_instance_ip 1):$2"
  scp "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} "$1" ${TF_VAR_default_username}@$(get_instance_ip 1):"$2"
}; _lcopyto1'

alias lcopyto2='function _lcopyto2() { 
  echo "üì§ Copying $1 to ${TF_VAR_default_username}@$(get_instance_ip 2):$2"
  scp "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} "$1" ${TF_VAR_default_username}@$(get_instance_ip 2):"$2"
}; _lcopyto2'

# =============================================================================
# STATUS & MONITORING (Optimization 5)
# =============================================================================

# Status and monitoring shortcuts
alias istatus='echo "üìä ${TF_VAR_env_prefix} Status:" && istate'

alias iping='for i in {0..2}; do 
  echo "üèì Pinging instance-$i:"
  timeout 3 ping -c 2 $(get_instance_ip $i) 2>/dev/null || echo "‚ùå Instance $i not reachable"
done'

alias ilogs='ssh "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} gpadmin@$(get_instance_ip 0) "sudo journalctl -f"'

alias itop='ssh "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} gpadmin@$(get_instance_ip 0) "htop"'

alias idisk='ssh "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} gpadmin@$(get_instance_ip 0) "df -h && echo && lsblk"'

# =============================================================================
# VS CODE & DEVELOPMENT
# =============================================================================

# Enhanced VS Code remote with error handling
alias icode='function _icode() {
  local path="${1:-/home/gpadmin}"
  local hostname=$(get_instance_ip 0)
  if [[ -n "$hostname" && "$hostname" != "None" ]]; then
    echo "üîó Opening VS Code remote to ${hostname}:${path}"
    /Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin/code --remote "ssh-remote+${TF_VAR_env_prefix}" "$path"
  else 
    echo "‚ùå Cannot connect - instance not running"
    return 1
  fi
}; _icode'

alias icloudberry='icode /home/gpadmin/cloudberry'

# =============================================================================
# UTILITY ALIASES
# =============================================================================

# Network and AWS utilities
alias myip='echo $(curl -s https://api.ipify.org)'
alias isso='aws sso login --sso-session your-sso-session'

# Spot instance availability checker aliases
alias spot-check='check_spot_availability'
alias spot-prices='check_spot_prices'

# Justfile integration (update path as needed)
alias j='just -f /home/gpadmin/cloudberry-devenv-launcher/docs/Justfile'

# Performance testing
alias itest='echo "üß™ Running performance tests..." && ./performance-test.sh'

# Environment info
alias iinfo='echo "üè∑Ô∏è  Environment: $TF_VAR_env_prefix" && 
echo "üåç Region: $TF_VAR_region" && 
echo "üë§ User: $TF_VAR_default_username" && 
echo "üÜî AMI: $TF_VAR_ami" && 
echo "üíª Instance Type: $TF_VAR_instance_type" && 
echo "üî¢ VM Count: $TF_VAR_vm_count"'

# OS version check
unalias ios 2>/dev/null || true
ios() {
    ssh "${SSH_OPTS[@]}" -i ${SSH_KEY_PATH} ${TF_VAR_default_username}@$(get_instance_ip 0) 'if [ -f /etc/os-release ]; then source /etc/os-release && echo $PRETTY_NAME; else cat /proc/version | sed "s/Linux version //" | cut -d" " -f1-2; fi' 2>/dev/null
}

# Terraform init aliases
alias ti='terraform init'      # Local backend (uses backend.tf config)
