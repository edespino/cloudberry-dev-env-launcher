#!/usr/bin/env bash
#
# OS Selector for Cloudberry Development Environment Launcher
# Creates a new environment directory based on selected OS from multi-os-sample
#

set -e

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(dirname "$SCRIPT_DIR")"
ENVIRONMENTS_DIR="$REPO_ROOT/environments"
TEMPLATE_DIR="$ENVIRONMENTS_DIR/multi-os-sample"

# Initialize empty arrays - defaults will be loaded from config
declare -A OS_OPTIONS
declare -A OS_GROUPS
declare -A AMI_OWNERS
declare -A AMI_FILTERS
declare -A DEFAULT_USERNAMES
declare -A DIR_NAMES
declare -A SELECTION_MAP

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Instance type options (standard AWS instance types)
declare -A INSTANCE_TYPES=(
    ["1"]="c7i.xlarge"
    ["2"]="c7i.2xlarge"
    ["3"]="c7i.4xlarge"
    ["4"]="c7i.8xlarge"
    ["5"]="c6i.xlarge"
    ["6"]="c6i.2xlarge"
    ["7"]="c6i.4xlarge"
    ["8"]="c6i.8xlarge"
    ["9"]="c5.xlarge"
    ["10"]="c5.2xlarge"
    ["11"]="c5.4xlarge"
    ["12"]="c5.9xlarge"
)
DEFAULT_INSTANCE_TYPE="c7i.4xlarge"

# Function to load all YAML configurations matching pattern
load_yaml_config() {
    local config_pattern="$REPO_ROOT/config/os-config-*.yaml"
    local config_files=($config_pattern)

    # Check if any config files exist
    if [[ ! -e "${config_files[0]}" ]]; then
        echo -e "${RED}‚ùå No configuration files found matching: $config_pattern${NC}"
        echo -e "${YELLOW}üí° Create at least one config file like: config/os-config-base.yaml${NC}"
        exit 1
    fi

    # Sort config files for consistent loading order
    IFS=$'\n' config_files=($(sort <<<"${config_files[*]}"))
    unset IFS

    # Check if yq is available
    if ! command -v yq &> /dev/null; then
        echo -e "${RED}‚ùå yq command not found. Please install yq to use YAML config files.${NC}"
        echo -e "${YELLOW}üí° Install with: brew install yq${NC}"
        exit 1
    fi

    if [[ "$DEBUG" == "1" ]]; then
        echo -e "${BLUE}üìÑ Loading ${#config_files[@]} configuration file(s):${NC}"
    fi

    # Track groups across files to detect duplicates
    declare -A groups_seen

    # Load each config file
    for config_file in "${config_files[@]}"; do
        if [[ "$DEBUG" == "1" ]]; then
            echo -e "${BLUE}  Loading: $(basename "$config_file")${NC}"
        fi

        # Parse YAML and populate arrays
        local keys=$(yq eval '.os_options | keys | .[]' "$config_file")

        for key in $keys; do
            # Check for duplicate group names across config files
            local group=$(yq eval ".os_options[\"$key\"].group" "$config_file")
            if [[ -n "$group" && -n "${groups_seen[$group]}" && "${groups_seen[$group]}" != "$config_file" ]]; then
                echo -e "${RED}‚ùå Error: Duplicate group name '${group}' found${NC}"
                echo -e "${YELLOW}   First defined in: ${groups_seen[$group]}${NC}"
                echo -e "${YELLOW}   Also found in: $config_file${NC}"
                exit 1
            fi
            [[ -n "$group" ]] && groups_seen["$group"]="$config_file"

            OS_OPTIONS["$key"]=$(yq eval ".os_options[\"$key\"].name" "$config_file")
            OS_GROUPS["$key"]="$group"
            AMI_OWNERS["$key"]=$(yq eval ".os_options[\"$key\"].ami_owner" "$config_file")
            AMI_FILTERS["$key"]=$(yq eval ".os_options[\"$key\"].ami_filter" "$config_file")
            DEFAULT_USERNAMES["$key"]=$(yq eval ".os_options[\"$key\"].username" "$config_file")
            DIR_NAMES["$key"]=$(yq eval ".os_options[\"$key\"].dir_name" "$config_file")
        done
    done

    if [[ "$DEBUG" == "1" ]]; then
        echo -e "${GREEN}‚úÖ All configurations loaded successfully!${NC}"
        echo -e "${BLUE}   Total options: ${#OS_OPTIONS[@]}${NC}"
        echo -e "${BLUE}   Total groups: ${#groups_seen[@]}${NC}"
        echo
    fi
}


# Debug/verbose mode (set DEBUG=1 to enable verbose output)
DEBUG="${DEBUG:-0}"

# Load OS configurations from all matching YAML files
# Pattern: config/os-config-*.yaml
# Files are loaded in alphabetical order and merged
load_yaml_config

# Function to display header
show_header() {
    echo -e "${BLUE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${BLUE}‚ïë${NC}            ${CYAN}Cloudberry Dev Environment OS Selector${NC}            ${BLUE}‚ïë${NC}"
    echo -e "${BLUE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo
}

# Function to display OS options grouped
show_options() {
    echo -e "${YELLOW}Available Operating Systems:${NC}"
    echo

    # Clear and rebuild the selection mapping
    unset SELECTION_MAP
    declare -gA SELECTION_MAP

    local counter=1
    local current_group=""

    # Get all keys and sort them (numeric first, then alphabetic)
    local keys=($(printf '%s\n' "${!OS_OPTIONS[@]}" | sort -V))

    # First, collect unique groups in order of appearance
    local -a group_order=()
    for key in "${keys[@]}"; do
        local group="${OS_GROUPS[$key]}"
        if [[ -n "$group" ]] && [[ ! " ${group_order[@]} " =~ " ${group} " ]]; then
            group_order+=("$group")
        fi
    done

    # Display options grouped
    for group in "${group_order[@]}"; do
        # Display group header
        echo -e "${CYAN}${group}:${NC}"

        # Display items in this group
        for key in "${keys[@]}"; do
            if [[ "${OS_GROUPS[$key]}" == "$group" && -n "${OS_OPTIONS[$key]}" ]]; then
                echo -e "  ${GREEN}[$counter]${NC} ${OS_OPTIONS[$key]} ${PURPLE}(${DIR_NAMES[$key]})${NC}"
                SELECTION_MAP["$counter"]="$key"
                ((counter++))
            fi
        done
        echo
    done
}

# Function to validate selection
validate_selection() {
    local selection=$1
    
    # Check if selection is empty
    if [[ -z "$selection" ]]; then
        local max_choice=${#SELECTION_MAP[@]}
        echo -e "${RED}‚ùå Please enter a selection (1-${max_choice}) or 'q' to quit.${NC}"
        return 1
    fi
    
    # Check if selection is a valid numeric choice
    if [[ -n "${SELECTION_MAP[$selection]}" ]]; then
        return 0
    else
        local max_choice=${#SELECTION_MAP[@]}
        echo -e "${RED}‚ùå Invalid selection. Please choose 1-${max_choice}.${NC}"
        return 1
    fi
}

# Function to check if template exists
check_template() {
    if [[ ! -d "$TEMPLATE_DIR" ]]; then
        echo -e "${RED}‚ùå Template directory not found: $TEMPLATE_DIR${NC}"
        echo -e "${YELLOW}üí° Make sure you're running this from the repository root${NC}"
        exit 1
    fi
}

# Function to display selected configuration
show_configuration() {
    local selection=$1
    local actual_key="${SELECTION_MAP[$selection]}"
    local os_name="${OS_OPTIONS[$actual_key]}"
    local dir_name="${DIR_NAMES[$actual_key]}"
    local ami_owner="${AMI_OWNERS[$actual_key]}"
    local ami_filter="${AMI_FILTERS[$actual_key]}"
    local username="${DEFAULT_USERNAMES[$actual_key]}"
    
    echo
    echo -e "${GREEN}‚úÖ Selected: ${CYAN}$os_name${NC}"
    echo
    echo -e "${YELLOW}Configuration Details:${NC}"
    echo -e "  ${PURPLE}Directory Name:${NC} $dir_name"
    echo -e "  ${PURPLE}AMI Owner:${NC} $ami_owner"
    echo -e "  ${PURPLE}AMI Filter:${NC} $ami_filter"
    echo -e "  ${PURPLE}Default Username:${NC} $username"
    echo
}

# Function to create environment directory
create_environment() {
    local selection=$1
    local custom_name="$2"
    local instance_type="$3"
    local use_spot="$4"
    local actual_key="${SELECTION_MAP[$selection]}"
    local os_name="${OS_OPTIONS[$actual_key]}"
    local dir_name="${DIR_NAMES[$actual_key]}"
    local ami_owner="${AMI_OWNERS[$actual_key]}"
    local ami_filter="${AMI_FILTERS[$actual_key]}"
    local username="${DEFAULT_USERNAMES[$actual_key]}"

    # Use custom name if provided, otherwise use default
    local target_name="${custom_name:-$dir_name}"
    local target_dir="$ENVIRONMENTS_DIR/$target_name"
    
    # Check if directory already exists
    if [[ -d "$target_dir" ]]; then
        echo -e "${RED}‚ùå Directory already exists: $target_dir${NC}"
        echo -n -e "${YELLOW}Overwrite? [y/N]: ${NC}"
        read -r confirm
        if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
            echo -e "${YELLOW}‚ùå Operation cancelled${NC}"
            exit 1
        fi
        rm -rf "$target_dir"
    fi
    
    # Copy template directory
    echo -e "${BLUE}üìÅ Copying template to $target_name...${NC}"
    cp -r "$TEMPLATE_DIR" "$target_dir"
    
    # Update .envrc with correct path and selected OS configuration
    local envrc_file="$target_dir/.envrc"
    if [[ -f "$envrc_file" ]]; then
        # Update the directory reference
        sed -i.bak "s|environments/[^/]*|environments/$target_name|g" "$envrc_file"

        # Replace instance type placeholder
        sed -i.bak2 "s|__INSTANCE_TYPE__|$instance_type|g" "$envrc_file"

        # Replace spot instance placeholder
        sed -i.bak3 "s|__USE_SPOT_INSTANCES__|$use_spot|g" "$envrc_file"

        # Replace the AMI configuration section with selected OS only
        # Use sed to replace the section between the markers
        sed -i.tmp '/^## Rocky Linux 9/,/^## ======================================================================/{
            /^## Rocky Linux 9/c\
## '"$os_name"'\
AMI_OWNER="'"$ami_owner"'"\
AMI_FILTER='"'"''"$ami_filter"''"'"'\
export TF_VAR_default_username="'"$username"'"\

            /^## ======================================================================/!d
        }' "$envrc_file"

        rm -f "$envrc_file.tmp"
        rm -f "$envrc_file.bak"
        rm -f "$envrc_file.bak2"
        rm -f "$envrc_file.bak3"
    fi
    
    # Create updated .env file
    local env_file="$target_dir/.env"
    cat > "$env_file" << EOF
# Enhanced .env for $os_name environment
# Created by os-selector on $(date)
# Loaded by zsh dotenv plugin for helpful aliases

# =============================================================================
# AMI CONFIGURATION
# =============================================================================

AMI_OWNER="$ami_owner"
AMI_FILTER='$ami_filter'
export TF_VAR_default_username="$username"

# =============================================================================
# SPOT INSTANCE AVAILABILITY CHECKER (sourced from shared library)
# =============================================================================

# Source shared spot checking functions
REPO_ROOT="\$(cd ../.. && pwd)"
if [[ -f "\$REPO_ROOT/lib/spot-functions.sh" ]]; then
    source "\$REPO_ROOT/lib/spot-functions.sh"
else
    echo "‚ö†Ô∏è  Warning: Shared spot functions not found at \$REPO_ROOT/lib/spot-functions.sh" >&2
fi

# Functions are now loaded from shared library above

# =============================================================================
# CORE FUNCTIONS (Optimizations 1, 4)
# =============================================================================

# IP lookup function (excludes terminated instances explicitly)
get_instance_ip() {
  local instance_index="\${1:-0}"
  
  # Fetch IP directly, explicitly excluding terminated instances
  local ip=\$(aws ec2 describe-instances --region "\$TF_VAR_region" \\
    --filters "Name=tag:Name,Values=\${TF_VAR_env_prefix}-instance-\${instance_index}" \\
              "Name=instance-state-name,Values=running" \\
    --query "Reservations[*].Instances[*].PublicIpAddress" \\
    --output text 2>/dev/null | head -n1)
  
  if [[ -n "\$ip" && "\$ip" != "None" && "\$ip" != "" ]]; then
    echo "\$ip"
  else
    echo "‚ùå No running instance found for \${TF_VAR_env_prefix}-instance-\${instance_index}" >&2
    return 1
  fi
}

# Function to safely clean IP cache files
clean_ip_cache() {
  setopt NULL_GLOB 2>/dev/null || true
  rm -f /tmp/\${TF_VAR_env_prefix}_ip_* 2>/dev/null || true
  unsetopt NULL_GLOB 2>/dev/null || true
}

# Enhanced function to retrieve the public IP and wait for SSH availability
wait_for_ssh() {
  local region="\$1"
  local env_prefix="\$2"
  local instance_index="\${3:-0}"
  local hostname

  # Retrieve the IP address using cached function
  hostname=\$(get_instance_ip "\$instance_index")

  if [ -z "\$hostname" ] || [ "\$hostname" = "None" ]; then
    echo "‚ùå Failed to retrieve IP address for \${env_prefix}-instance-\${instance_index} in region \${region}."
    return 1
  fi

  echo "‚è≥ Waiting for SSH to become available on \${hostname}..."

  for ((i=1; i<=30; i++)); do
    if timeout 5 nc -z "\$hostname" 22 2>/dev/null; then
      echo "‚úÖ SSH is available on \${hostname}"
      break
    else
      echo "‚è≥ SSH not ready (attempt \$i/30). Retrying..."
      sleep \$((i*2))
    fi

    if [ \$i -eq 30 ]; then
      echo "‚ùå SSH is still not available after 30 attempts. Exiting."
      rename_ami "FAILED"
      cleanup
      exit 1
    fi
  done
}

# SSH connection options with timeouts (as array for proper expansion)
SSH_OPTS=(-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10 -o LogLevel=ERROR)

# NOTE: SSH key path is set in .envrc
## SSH_KEY_PATH="\${TF_VAR_env_prefix}_generated_key.pem"

# =============================================================================
# SSH ALIASES (Optimizations 2, 8) - DRY User Alias Generator
# =============================================================================

# Function to create user-specific SSH and file transfer aliases
# Usage: create_user_ssh_aliases <username> <ssh_prefix> <wait_prefix>
create_user_ssh_aliases() {
  local username="\$1"
  local ssh_prefix="\$2"      # e.g., "lc" for cbadmin, "lg" for gpadmin
  local wait_prefix="\$3"     # e.g., "lcw" for cbadmin, "lgw" for gpadmin

  # Wait and copy SSH key to user
  alias \${wait_prefix}='wait_for_ssh \${TF_VAR_region} \${TF_VAR_env_prefix}; \\
             ssh "\${SSH_OPTS[@]}" \\
                 -i \${SSH_KEY_PATH} \\
                 \${TF_VAR_default_username}@\$(get_instance_ip 0) \\
                 "cat ~/.ssh/authorized_keys | sudo tee -a ~'\$username'/.ssh/authorized_keys > /dev/null" && \\
             echo "‚úÖ SSH key copied to '\$username' user"'

  # SSH connections for 3 instances
  alias \${ssh_prefix}ssh='ssh "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} '\$username'@\$(get_instance_ip 0) -A'
  alias \${ssh_prefix}ssh1='ssh "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} '\$username'@\$(get_instance_ip 1) -A'
  alias \${ssh_prefix}ssh2='ssh "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} '\$username'@\$(get_instance_ip 2) -A'

  # File transfer - copy to
  alias \${ssh_prefix}copyto='function _'\${ssh_prefix}'copyto() {
    echo "üì§ Copying \$1 to '\$username'@\$(get_instance_ip 0):\$2"
    scp "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} "\$1" '\$username'@\$(get_instance_ip 0):"\$2"
  }; _'\${ssh_prefix}'copyto'

  # File transfer - copy from
  alias \${ssh_prefix}copyfrom='function _'\${ssh_prefix}'copyfrom() {
    echo "üì• Copying '\$username'@\$(get_instance_ip 0):\$1 to \$2"
    scp "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} '\$username'@\$(get_instance_ip 0):"\$1" "\$2"
  }; _'\${ssh_prefix}'copyfrom'
}

# Wait for SSH (enhanced with multi-instance support)
alias lw='wait_for_ssh \${TF_VAR_region} \${TF_VAR_env_prefix}'
alias lw1='wait_for_ssh \${TF_VAR_region} \${TF_VAR_env_prefix} 1'
alias lw2='wait_for_ssh \${TF_VAR_region} \${TF_VAR_env_prefix} 2'

# Default user SSH connections (using cached IPs and timeouts)
alias lssh='ssh "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} \${TF_VAR_default_username}@\$(get_instance_ip 0) -A'
alias lssh1='ssh "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} \${TF_VAR_default_username}@\$(get_instance_ip 1) -A'
alias lssh2='ssh "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} \${TF_VAR_default_username}@\$(get_instance_ip 2) -A'

# Create cbadmin aliases (backward compatible: lcssh, lcw, lccopyto, etc.)
create_user_ssh_aliases "cbadmin" "lc" "lcw"

# Create gpadmin aliases (new: lgssh, lgw, lgcopyto, etc.)
create_user_ssh_aliases "gpadmin" "lg" "lgw"

# =============================================================================
# INSTANCE MANAGEMENT (Optimization 3)
# =============================================================================

# Instance state with enhanced output (excluding terminated instances)
alias istate='aws ec2 describe-instances --region "\$TF_VAR_region" \\
  --filters "Name=tag:Name,Values=\${TF_VAR_env_prefix}-instance-*" \\
            "Name=instance-state-name,Values=pending,running,shutting-down,stopping,stopped" \\
  --query "Reservations[].Instances[].[Tags[?Key==\\\`Name\\\`].Value|[0], State.Name, InstanceType, PublicIpAddress, PrivateIpAddress]" \\
  --output table'

# All non-terminated instances across the project
alias iastate='aws ec2 describe-instances --region "\$TF_VAR_region" \\
  --filters "Name=instance-state-name,Values=pending,running,shutting-down,stopping,stopped" \\
  --query "Reservations[].Instances[].[Tags[?Key==\\\`Name\\\`].Value|[0], State.Name, InstanceType, PublicIpAddress, PrivateIpAddress]" \\
  --output table'

# Instance start with cache invalidation
alias istart='echo "üöÄ Starting instances..." && \\
  STOPPED_IDS=\$(aws ec2 describe-instances --region "\$TF_VAR_region" \\
    --filters "Name=tag:Name,Values=\${TF_VAR_env_prefix}-instance-*" "Name=instance-state-name,Values=stopped" \\
    --query "Reservations[].Instances[].InstanceId" --output text) && \\
  if [[ -n "\$STOPPED_IDS" ]]; then \\
    aws ec2 start-instances --region "\$TF_VAR_region" --instance-ids \$STOPPED_IDS && \\
    echo "‚è≥ Waiting for instances to be running..." && \\
    aws ec2 wait instance-running --region "\$TF_VAR_region" --instance-ids \$STOPPED_IDS && \\
    echo "‚úÖ Instances are now running"; \\
  else \\
    echo "‚ÑπÔ∏è  No stopped instances found to start"; \\
  fi; \\
  clean_ip_cache'

# Instance stop with cache invalidation
alias istop='echo "üõë Stopping instances..." && \\
  RUNNING_IDS=\$(aws ec2 describe-instances --region "\$TF_VAR_region" \\
    --filters "Name=tag:Name,Values=\${TF_VAR_env_prefix}-instance-*" "Name=instance-state-name,Values=running" \\
    --query "Reservations[].Instances[].InstanceId" --output text) && \\
  if [[ -n "\$RUNNING_IDS" ]]; then \\
    aws ec2 stop-instances --region "\$TF_VAR_region" --no-hibernate --instance-ids \$RUNNING_IDS && \\
    echo "‚è≥ Waiting for instances to stop..." && \\
    aws ec2 wait instance-stopped --region "\$TF_VAR_region" --instance-ids \$RUNNING_IDS && \\
    echo "‚úÖ Instances are now stopped"; \\
  else \\
    echo "‚ÑπÔ∏è  No running instances found to stop"; \\
  fi; \\
  clean_ip_cache'

# Refresh with cache invalidation
alias irefresh='clean_ip_cache && echo "‚úÖ IP cache refreshed"'

# =============================================================================
# FILE TRANSFER (Optimization 6)
# =============================================================================
# Note: User-specific file transfer aliases (lccopyto, lccopyfrom, lgcopyto, lgcopyfrom)
# are now created by create_user_ssh_aliases() function above

# Default user file transfer aliases with progress feedback
alias lcopyto='function _lcopyto() {
  echo "üì§ Copying \$1 to \${TF_VAR_default_username}@\$(get_instance_ip 0):\$2"
  scp "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} "\$1" \${TF_VAR_default_username}@\$(get_instance_ip 0):"\$2"
}; _lcopyto'

alias lcopyfrom='function _lcopyfrom() {
  echo "üì• Copying \${TF_VAR_default_username}@\$(get_instance_ip 0):\$1 to \$2"
  scp "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} \${TF_VAR_default_username}@\$(get_instance_ip 0):"\$1" "\$2"
}; _lcopyfrom'

# Multi-instance SCP for default user
alias lcopyto1='function _lcopyto1() {
  echo "üì§ Copying \$1 to \${TF_VAR_default_username}@\$(get_instance_ip 1):\$2"
  scp "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} "\$1" \${TF_VAR_default_username}@\$(get_instance_ip 1):"\$2"
}; _lcopyto1'

alias lcopyto2='function _lcopyto2() {
  echo "üì§ Copying \$1 to \${TF_VAR_default_username}@\$(get_instance_ip 2):\$2"
  scp "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} "\$1" \${TF_VAR_default_username}@\$(get_instance_ip 2):"\$2"
}; _lcopyto2'

# =============================================================================
# STATUS & MONITORING (Optimization 5) - DRY User Monitoring Generator
# =============================================================================

# Function to create user-specific monitoring aliases
# Usage: create_user_monitoring_aliases <username> <prefix>
create_user_monitoring_aliases() {
  local username="\$1"
  local prefix="\$2"  # Empty for cbadmin (backward compatible), "g" for gpadmin

  # Logs - follow system journal
  alias \${prefix}logs='ssh "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} '\$username'@\$(get_instance_ip 0) "sudo journalctl -f"'

  # Top - system resource monitoring
  alias \${prefix}top='ssh "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} '\$username'@\$(get_instance_ip 0) "htop"'

  # Disk - disk usage and block devices
  alias \${prefix}disk='ssh "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} '\$username'@\$(get_instance_ip 0) "df -h && echo && lsblk"'
}

# Status and monitoring shortcuts (generic, not user-specific)
alias istatus='echo "üìä \${TF_VAR_env_prefix} Status:" && istate'

alias iping='for i in {0..2}; do
  echo "üèì Pinging instance-\$i:"
  timeout 3 ping -c 2 \$(get_instance_ip \$i) 2>/dev/null || echo "‚ùå Instance \$i not reachable"
done'

# Create cbadmin monitoring aliases (backward compatible: ilogs, itop, idisk)
create_user_monitoring_aliases "cbadmin" "i"

# Create gpadmin monitoring aliases (new: glogs, gtop, gdisk)
create_user_monitoring_aliases "gpadmin" "g"

# =============================================================================
# VS CODE & DEVELOPMENT - DRY User VS Code Generator
# =============================================================================

# Function to create user-specific VS Code aliases
# Usage: create_user_vscode_aliases <username> <prefix>
create_user_vscode_aliases() {
  local username="\$1"
  local prefix="\$2"  # Empty for cbadmin (backward compatible), "g" for gpadmin

  # VS Code remote with error handling
  alias \${prefix}code='function _'\${prefix}'code() {
    local path="\${1:-/home/'\$username'}"
    local hostname=\$(get_instance_ip 0)
    if [[ -n "\$hostname" && "\$hostname" != "None" ]]; then
      echo "üîó Opening VS Code remote to \${hostname}:\${path}"
      /Applications/Visual\\ Studio\\ Code.app/Contents/Resources/app/bin/code --remote "ssh-remote+\${TF_VAR_env_prefix}" "\$path"
    else
      echo "‚ùå Cannot connect - instance not running"
      return 1
    fi
  }; _'\${prefix}'code'

  # Shortcut for cloudberry directory
  alias \${prefix}cloudberry="\${prefix}code /home/\$username/cloudberry"
}

# Create cbadmin VS Code aliases (backward compatible: icode, icloudberry)
create_user_vscode_aliases "cbadmin" "i"

# Create gpadmin VS Code aliases (new: gcode, gcloudberry)
create_user_vscode_aliases "gpadmin" "g"

# =============================================================================
# UTILITY ALIASES
# =============================================================================

# Network and AWS utilities
alias myip='echo \$(curl -s https://api.ipify.org)'
alias isso='aws sso login --sso-session your-sso-session'

# Spot instance availability checker aliases
alias spot-check='check_spot_availability'
alias spot-prices='check_spot_prices'

# Justfile integration (update path as needed)
alias j='just -f /home/cbadmin/cloudberry-devenv-launcher/docs/Justfile'

# Performance testing
alias itest='echo "üß™ Running performance tests..." && ./performance-test.sh'

# Environment info
alias iinfo='echo "üè∑Ô∏è  Environment: \$TF_VAR_env_prefix" && 
echo "üåç Region: \$TF_VAR_region" && 
echo "üë§ User: \$TF_VAR_default_username" && 
echo "üÜî AMI: \$TF_VAR_ami" && 
echo "üíª Instance Type: \$TF_VAR_instance_type" && 
echo "üî¢ VM Count: \$TF_VAR_vm_count"'

# OS version check
unalias ios 2>/dev/null || true
ios() {
    ssh "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} \${TF_VAR_default_username}@\$(get_instance_ip 0) 'if [ -f /etc/os-release ]; then source /etc/os-release && echo \$PRETTY_NAME; else cat /proc/version | sed "s/Linux version //" | cut -d" " -f1-2; fi' 2>/dev/null
}

# Terraform init aliases
alias ti='terraform init'      # Local backend (uses backend.tf config)
EOF
    
    # No need to modify main.tf - template now uses generic names
    
    echo -e "${GREEN}‚ú® Environment created successfully!${NC}"
    echo
    echo -e "${YELLOW}üìÅ Location:${NC} $target_dir"
    echo -e "${YELLOW}üîß Next steps:${NC}"
    echo -e "  1. ${CYAN}cd $target_dir${NC}"
    echo -e "  2. ${CYAN}direnv allow .${NC}"
    echo -e "  3. ${CYAN}terraform init${NC}"
    echo -e "  4. ${CYAN}terraform plan${NC}"
    echo -e "  5. ${CYAN}terraform apply${NC}"
    echo
}

# Function to get OS selection
get_os_selection() {
    while true; do
        show_options
        
        local max_choice=${#SELECTION_MAP[@]}
        echo -n -e "${YELLOW}Select an OS [1-${max_choice}] or 'q' to quit: ${NC}"
        read -r selection
        
        # Check for quit
        if [[ "$selection" == "q" || "$selection" == "Q" ]]; then
            echo -e "${YELLOW}üëã Goodbye!${NC}"
            exit 0
        fi
        
        # Validate selection
        if validate_selection "$selection"; then
            return 0
        fi
        
        echo
        echo -e "${RED}‚ùå Invalid selection. Please try again.${NC}"
        echo
    done
}

# Function to get directory name choice
get_directory_name() {
    local selection=$1
    local actual_key="${SELECTION_MAP[$selection]}"
    local custom_name=""
    
    while true; do
        echo -e "${YELLOW}Directory name options:${NC}"
        echo -e "  ${GREEN}[1]${NC} Use default name: ${CYAN}${DIR_NAMES[$actual_key]}${NC} ${PURPLE}(default)${NC}"
        echo -e "  ${GREEN}[2]${NC} Enter custom name"
        echo -e "  ${GREEN}[b]${NC} Back to OS selection"
        echo
        echo -n -e "${YELLOW}Choose option [1/2/b] (default: 1): ${NC}"
        read -r name_choice
        
        # Default to option 1 if empty
        if [[ -z "$name_choice" ]]; then
            name_choice="1"
        fi
        
        case "$name_choice" in
            "1")
                custom_name=""
                break
                ;;
            "2")
                echo -n -e "${YELLOW}Enter custom directory name: ${NC}"
                read -r custom_name
                if [[ -z "$custom_name" ]]; then
                    echo -e "${RED}‚ùå Empty name not allowed${NC}"
                    echo
                    continue
                fi
                # Validate directory name (basic check)
                if [[ ! "$custom_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
                    echo -e "${RED}‚ùå Invalid directory name. Use only letters, numbers, hyphens, and underscores.${NC}"
                    echo
                    continue
                fi
                break
                ;;
            "b"|"B")
                return 1  # Signal to go back
                ;;
            *)
                echo -e "${RED}‚ùå Invalid option. Please choose 1, 2, or b.${NC}"
                echo
                ;;
        esac
    done
    
    # Return the custom name via a global variable
    SELECTED_CUSTOM_NAME="$custom_name"
    return 0
}

# Function to get instance type selection
get_instance_type() {
    while true; do
        echo
        echo -e "${YELLOW}Select Instance Type:${NC}"
        echo
        echo -e "${CYAN}Compute-Optimized Instances:${NC}"
        echo
        echo -e "  ${GREEN}C7i Generation (Latest):${NC}"
        echo -e "    ${GREEN}[1]${NC}  c7i.xlarge    (4 vCPU, 8 GB)"
        echo -e "    ${GREEN}[2]${NC}  c7i.2xlarge   (8 vCPU, 16 GB)"
        echo -e "    ${GREEN}[3]${NC}  c7i.4xlarge   (16 vCPU, 32 GB) ${PURPLE}[default]${NC}"
        echo -e "    ${GREEN}[4]${NC}  c7i.8xlarge   (32 vCPU, 64 GB)"
        echo
        echo -e "  ${GREEN}C6i Generation:${NC}"
        echo -e "    ${GREEN}[5]${NC}  c6i.xlarge    (4 vCPU, 8 GB)"
        echo -e "    ${GREEN}[6]${NC}  c6i.2xlarge   (8 vCPU, 16 GB)"
        echo -e "    ${GREEN}[7]${NC}  c6i.4xlarge   (16 vCPU, 32 GB)"
        echo -e "    ${GREEN}[8]${NC}  c6i.8xlarge   (32 vCPU, 64 GB)"
        echo
        echo -e "  ${GREEN}C5 Generation:${NC}"
        echo -e "    ${GREEN}[9]${NC}  c5.xlarge     (4 vCPU, 8 GB)"
        echo -e "    ${GREEN}[10]${NC} c5.2xlarge   (8 vCPU, 16 GB)"
        echo -e "    ${GREEN}[11]${NC} c5.4xlarge    (16 vCPU, 32 GB)"
        echo -e "    ${GREEN}[12]${NC} c5.9xlarge   (36 vCPU, 72 GB)"
        echo
        echo -n -e "${YELLOW}Select instance type [1-12] or press Enter for default (${DEFAULT_INSTANCE_TYPE}): ${NC}"
        read -r choice

        # Default to c7i.4xlarge if empty
        if [[ -z "$choice" ]]; then
            SELECTED_INSTANCE_TYPE="$DEFAULT_INSTANCE_TYPE"
            return 0
        fi

        # Validate choice
        if [[ -n "${INSTANCE_TYPES[$choice]}" ]]; then
            SELECTED_INSTANCE_TYPE="${INSTANCE_TYPES[$choice]}"
            return 0
        else
            echo -e "${RED}‚ùå Invalid selection. Please choose 1-12.${NC}"
            echo
        fi
    done
}

# Function to get spot instance preference
get_spot_instances() {
    while true; do
        echo
        echo -e "${YELLOW}Enable Spot Instances?${NC}"
        echo
        echo -e "  ${CYAN}Spot instances can save up to 90% on EC2 costs but may be interrupted.${NC}"
        echo
        echo -e "  ${GREEN}[1]${NC} No - Use On-Demand instances ${PURPLE}(default, more reliable)${NC}"
        echo -e "  ${GREEN}[2]${NC} Yes - Use Spot instances ${PURPLE}(cheaper, may be interrupted)${NC}"
        echo
        echo -n -e "${YELLOW}Select option [1/2] or press Enter for default (On-Demand): ${NC}"
        read -r choice

        # Default to false (on-demand) if empty
        if [[ -z "$choice" ]]; then
            choice="1"
        fi

        case "$choice" in
            "1")
                SELECTED_USE_SPOT="false"
                return 0
                ;;
            "2")
                SELECTED_USE_SPOT="true"
                return 0
                ;;
            *)
                echo -e "${RED}‚ùå Invalid selection. Please choose 1 or 2.${NC}"
                echo
                ;;
        esac
    done
}

# Function to confirm environment creation
confirm_creation() {
    local selection=$1
    local custom_name="$2"
    local instance_type="$3"
    local use_spot="$4"
    local actual_key="${SELECTION_MAP[$selection]}"
    local os_name="${OS_OPTIONS[$actual_key]}"
    local dir_name="${custom_name:-${DIR_NAMES[$actual_key]}}"

    while true; do
        echo
        echo -e "${CYAN}üìã Summary:${NC}"
        echo -e "  ${PURPLE}OS:${NC} $os_name"
        echo -e "  ${PURPLE}Directory:${NC} $dir_name"
        echo -e "  ${PURPLE}AMI Owner:${NC} ${AMI_OWNERS[$actual_key]}"
        echo -e "  ${PURPLE}AMI Filter:${NC} ${AMI_FILTERS[$actual_key]}"
        echo -e "  ${PURPLE}Username:${NC} ${DEFAULT_USERNAMES[$actual_key]}"
        echo -e "  ${PURPLE}Instance Type:${NC} $instance_type"
        echo -e "  ${PURPLE}Spot Instances:${NC} $([ "$use_spot" = "true" ] && echo "‚úì Enabled" || echo "‚úó Disabled")"
        echo
        echo -e "${YELLOW}Actions:${NC}"
        echo -e "  ${GREEN}[c]${NC} Create environment ${PURPLE}(default)${NC}"
        echo -e "  ${GREEN}[b]${NC} Back to instance configuration"
        echo -e "  ${GREEN}[o]${NC} Back to OS selection"
        echo -e "  ${GREEN}[q]${NC} Quit"
        echo
        echo -n -e "${YELLOW}Choose action [c/b/o/q] (default: c): ${NC}"
        read -r action

        # Default to create if empty
        if [[ -z "$action" ]]; then
            action="c"
        fi

        case "$action" in
            "c"|"C")
                return 0  # Proceed with creation
                ;;
            "b"|"B")
                return 1  # Go back to instance configuration
                ;;
            "o"|"O")
                return 2  # Go back to OS selection
                ;;
            "q"|"Q")
                echo -e "${YELLOW}üëã Goodbye!${NC}"
                exit 0
                ;;
            *)
                echo -e "${RED}‚ùå Invalid option. Please choose c, b, o, or q.${NC}"
                echo
                ;;
        esac
    done
}

# Main function with navigation flow
main() {
    clear
    check_template
    show_header

    while true; do
        # Step 1: Get OS selection
        get_os_selection
        local selection=$selection

        while true; do
            # Show configuration for selected OS
            show_configuration "$selection"

            # Step 2: Get directory name
            if get_directory_name "$selection"; then
                local custom_name="$SELECTED_CUSTOM_NAME"

                while true; do
                    # Step 3: Get instance type
                    get_instance_type
                    local instance_type="$SELECTED_INSTANCE_TYPE"

                    # Step 4: Get spot instance preference
                    get_spot_instances
                    local use_spot="$SELECTED_USE_SPOT"

                    # Step 5: Confirm and create
                    local confirm_result
                    confirm_creation "$selection" "$custom_name" "$instance_type" "$use_spot"
                    confirm_result=$?

                    case $confirm_result in
                        0)
                            # Create environment and exit
                            create_environment "$selection" "$custom_name" "$instance_type" "$use_spot"
                            exit 0
                            ;;
                        1)
                            # Go back to instance configuration - continue inner loop
                            continue
                            ;;
                        2)
                            # Go back to OS selection - break all inner loops
                            break 2
                            ;;
                    esac
                done
            else
                # User chose to go back to OS selection
                break
            fi
        done
    done
}

# Run main function
main "$@"
