#!/usr/bin/env bash
#
# OS Selector for Cloudberry Development Environment Launcher
# Creates a new environment directory based on selected OS from multi-os-sample
#

set -e

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(dirname "$SCRIPT_DIR")"
ENVIRONMENTS_DIR="$REPO_ROOT/environments"
TEMPLATE_DIR="$ENVIRONMENTS_DIR/multi-os-sample"

# Initialize empty arrays - defaults will be loaded from config
declare -A OS_OPTIONS
declare -A AMI_OWNERS
declare -A AMI_FILTERS
declare -A DEFAULT_USERNAMES
declare -A DIR_NAMES
declare -A SELECTION_MAP

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Function to load YAML configuration
load_yaml_config() {
    local yaml_file="$1"
    
    # Check if yq is available
    if ! command -v yq &> /dev/null; then
        echo -e "${RED}❌ yq command not found. Please install yq to use YAML config files.${NC}"
        echo -e "${YELLOW}💡 Install with: brew install yq${NC}"
        exit 1
    fi
    
    # Parse YAML and populate arrays
    local keys=$(yq eval '.os_options | keys | .[]' "$yaml_file")
    
    for key in $keys; do
        OS_OPTIONS["$key"]=$(yq eval ".os_options[\"$key\"].name" "$yaml_file")
        AMI_OWNERS["$key"]=$(yq eval ".os_options[\"$key\"].ami_owner" "$yaml_file")
        AMI_FILTERS["$key"]=$(yq eval ".os_options[\"$key\"].ami_filter" "$yaml_file")
        DEFAULT_USERNAMES["$key"]=$(yq eval ".os_options[\"$key\"].username" "$yaml_file")
        DIR_NAMES["$key"]=$(yq eval ".os_options[\"$key\"].dir_name" "$yaml_file")
    done
    
    echo "YAML configuration loaded successfully! Available options: ${!OS_OPTIONS[*]}"
}


# Load OS configurations (required)
# Priority: YAML > Bash (simplified)
CUSTOM_CONFIG_YAML="${CUSTOM_CONFIG_YAML:-$REPO_ROOT/config/os-config.yaml}"
CUSTOM_CONFIG_BASH="${CUSTOM_CONFIG_BASH:-$REPO_ROOT/config/os-config.sh}"

# Check for multiple config files and warn user
config_files_found=()
[[ -f "$CUSTOM_CONFIG_YAML" ]] && config_files_found+=("YAML: $CUSTOM_CONFIG_YAML")
[[ -f "$CUSTOM_CONFIG_BASH" ]] && config_files_found+=("Bash: $CUSTOM_CONFIG_BASH")

if [[ ${#config_files_found[@]} -gt 1 ]]; then
    echo -e "${YELLOW}⚠️  Multiple configuration files found:${NC}"
    for config in "${config_files_found[@]}"; do
        echo -e "   - $config"
    done
    echo -e "${YELLOW}💡 Using priority: YAML > Bash${NC}"
    echo
fi

# Load the highest priority config file
if [[ -f "$CUSTOM_CONFIG_YAML" ]]; then
    echo -e "${BLUE}📄 Loading OS configurations from $CUSTOM_CONFIG_YAML${NC}"
    load_yaml_config "$CUSTOM_CONFIG_YAML"
elif [[ -f "$CUSTOM_CONFIG_BASH" ]]; then
    echo -e "${BLUE}📄 Loading OS configurations from $CUSTOM_CONFIG_BASH${NC}"
    source "$CUSTOM_CONFIG_BASH"
else
    echo -e "${RED}❌ No configuration file found${NC}"
    echo -e "${YELLOW}💡 Create one of:${NC}"
    echo -e "   - ${CYAN}$CUSTOM_CONFIG_YAML${NC} (YAML format - recommended)"
    echo -e "   - ${CYAN}$CUSTOM_CONFIG_BASH${NC} (Bash format - legacy)"
    echo -e "${YELLOW}💡 See config/README.md for examples${NC}"
    exit 1
fi

# Function to display header
show_header() {
    echo -e "${BLUE}╔══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BLUE}║${NC}          ${CYAN}Cloudberry Dev Environment OS Selector${NC}          ${BLUE}║${NC}"
    echo -e "${BLUE}╚══════════════════════════════════════════════════════════════╝${NC}"
    echo
}

# Function to display OS options
show_options() {
    echo -e "${YELLOW}Available Operating Systems:${NC}"
    echo
    # Get all keys and sort them (numeric first, then alphabetic)
    local keys=($(printf '%s\n' "${!OS_OPTIONS[@]}" | sort -V))
    local counter=1
    
    # Clear and rebuild the selection mapping
    unset SELECTION_MAP
    declare -gA SELECTION_MAP
    
    for key in "${keys[@]}"; do
        if [[ -n "${OS_OPTIONS[$key]}" ]]; then
            echo -e "  ${GREEN}[$counter]${NC} ${OS_OPTIONS[$key]} ${PURPLE}(${DIR_NAMES[$key]})${NC}"
            SELECTION_MAP["$counter"]="$key"
            ((counter++))
        fi
    done
    echo
}

# Function to validate selection
validate_selection() {
    local selection=$1
    
    # Check if selection is empty
    if [[ -z "$selection" ]]; then
        local max_choice=${#SELECTION_MAP[@]}
        echo -e "${RED}❌ Please enter a selection (1-${max_choice}) or 'q' to quit.${NC}"
        return 1
    fi
    
    # Check if selection is a valid numeric choice
    if [[ -n "${SELECTION_MAP[$selection]}" ]]; then
        return 0
    else
        local max_choice=${#SELECTION_MAP[@]}
        echo -e "${RED}❌ Invalid selection. Please choose 1-${max_choice}.${NC}"
        return 1
    fi
}

# Function to check if template exists
check_template() {
    if [[ ! -d "$TEMPLATE_DIR" ]]; then
        echo -e "${RED}❌ Template directory not found: $TEMPLATE_DIR${NC}"
        echo -e "${YELLOW}💡 Make sure you're running this from the repository root${NC}"
        exit 1
    fi
}

# Function to display selected configuration
show_configuration() {
    local selection=$1
    local actual_key="${SELECTION_MAP[$selection]}"
    local os_name="${OS_OPTIONS[$actual_key]}"
    local dir_name="${DIR_NAMES[$actual_key]}"
    local ami_owner="${AMI_OWNERS[$actual_key]}"
    local ami_filter="${AMI_FILTERS[$actual_key]}"
    local username="${DEFAULT_USERNAMES[$actual_key]}"
    
    echo
    echo -e "${GREEN}✅ Selected: ${CYAN}$os_name${NC}"
    echo
    echo -e "${YELLOW}Configuration Details:${NC}"
    echo -e "  ${PURPLE}Directory Name:${NC} $dir_name"
    echo -e "  ${PURPLE}AMI Owner:${NC} $ami_owner"
    echo -e "  ${PURPLE}AMI Filter:${NC} $ami_filter"
    echo -e "  ${PURPLE}Default Username:${NC} $username"
    echo
}

# Function to create environment directory
create_environment() {
    local selection=$1
    local custom_name="$2"
    local actual_key="${SELECTION_MAP[$selection]}"
    local os_name="${OS_OPTIONS[$actual_key]}"
    local dir_name="${DIR_NAMES[$actual_key]}"
    local ami_owner="${AMI_OWNERS[$actual_key]}"
    local ami_filter="${AMI_FILTERS[$actual_key]}"
    local username="${DEFAULT_USERNAMES[$actual_key]}"
    
    # Use custom name if provided, otherwise use default
    local target_name="${custom_name:-$dir_name}"
    local target_dir="$ENVIRONMENTS_DIR/$target_name"
    
    # Check if directory already exists
    if [[ -d "$target_dir" ]]; then
        echo -e "${RED}❌ Directory already exists: $target_dir${NC}"
        echo -n -e "${YELLOW}Overwrite? [y/N]: ${NC}"
        read -r confirm
        if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
            echo -e "${YELLOW}❌ Operation cancelled${NC}"
            exit 1
        fi
        rm -rf "$target_dir"
    fi
    
    # Copy template directory
    echo -e "${BLUE}📁 Copying template to $target_name...${NC}"
    cp -r "$TEMPLATE_DIR" "$target_dir"
    
    # Update .envrc with correct path and selected OS configuration
    local envrc_file="$target_dir/.envrc"
    if [[ -f "$envrc_file" ]]; then
        # Update the directory reference
        sed -i.bak "s|environments/[^/]*|environments/$target_name|g" "$envrc_file"
        
        # Replace the AMI configuration section with selected OS only
        # Use sed to replace the section between the markers
        sed -i.tmp '/^## Rocky Linux 9/,/^## ======================================================================/{
            /^## Rocky Linux 9/c\
## '"$os_name"'\
AMI_OWNER="'"$ami_owner"'"\
AMI_FILTER='"'"''"$ami_filter"''"'"'\
export TF_VAR_default_username="'"$username"'"\

            /^## ======================================================================/!d
        }' "$envrc_file"
        
        rm -f "$envrc_file.tmp"
        rm -f "$envrc_file.bak"
    fi
    
    # Create updated .env file
    local env_file="$target_dir/.env"
    cat > "$env_file" << EOF
# Enhanced .env for $os_name environment
# Created by os-selector on $(date)
# Loaded by zsh dotenv plugin for helpful aliases

# =============================================================================
# AMI CONFIGURATION
# =============================================================================

AMI_OWNER="$ami_owner"
AMI_FILTER='$ami_filter'
export TF_VAR_default_username="$username"

# =============================================================================
# SPOT INSTANCE AVAILABILITY CHECKER (sourced from shared library)
# =============================================================================

# Source shared spot checking functions
REPO_ROOT="\$(cd ../.. && pwd)"
if [[ -f "\$REPO_ROOT/lib/spot-functions.sh" ]]; then
    source "\$REPO_ROOT/lib/spot-functions.sh"
else
    echo "⚠️  Warning: Shared spot functions not found at \$REPO_ROOT/lib/spot-functions.sh" >&2
fi

# Functions are now loaded from shared library above

# =============================================================================
# CORE FUNCTIONS (Optimizations 1, 4)
# =============================================================================

# IP lookup function (excludes terminated instances explicitly)
get_instance_ip() {
  local instance_index="\${1:-0}"
  
  # Fetch IP directly, explicitly excluding terminated instances
  local ip=\$(aws ec2 describe-instances --region "\$TF_VAR_region" \\
    --filters "Name=tag:Name,Values=\${TF_VAR_env_prefix}-instance-\${instance_index}" \\
              "Name=instance-state-name,Values=running" \\
    --query "Reservations[*].Instances[*].PublicIpAddress" \\
    --output text 2>/dev/null | head -n1)
  
  if [[ -n "\$ip" && "\$ip" != "None" && "\$ip" != "" ]]; then
    echo "\$ip"
  else
    echo "❌ No running instance found for \${TF_VAR_env_prefix}-instance-\${instance_index}" >&2
    return 1
  fi
}

# Function to safely clean IP cache files
clean_ip_cache() {
  setopt NULL_GLOB 2>/dev/null || true
  rm -f /tmp/\${TF_VAR_env_prefix}_ip_* 2>/dev/null || true
  unsetopt NULL_GLOB 2>/dev/null || true
}

# Enhanced function to retrieve the public IP and wait for SSH availability
wait_for_ssh() {
  local region="\$1"
  local env_prefix="\$2"
  local instance_index="\${3:-0}"
  local hostname

  # Retrieve the IP address using cached function
  hostname=\$(get_instance_ip "\$instance_index")

  if [ -z "\$hostname" ] || [ "\$hostname" = "None" ]; then
    echo "❌ Failed to retrieve IP address for \${env_prefix}-instance-\${instance_index} in region \${region}."
    return 1
  fi

  echo "⏳ Waiting for SSH to become available on \${hostname}..."

  for ((i=1; i<=30; i++)); do
    if timeout 5 nc -z "\$hostname" 22 2>/dev/null; then
      echo "✅ SSH is available on \${hostname}"
      break
    else
      echo "⏳ SSH not ready (attempt \$i/30). Retrying..."
      sleep \$((i*2))
    fi

    if [ \$i -eq 30 ]; then
      echo "❌ SSH is still not available after 30 attempts. Exiting."
      rename_ami "FAILED"
      cleanup
      exit 1
    fi
  done
}

# SSH connection options with timeouts (as array for proper expansion)
SSH_OPTS=(-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10)

# NOTE: SSH key path is set in .envrc
## SSH_KEY_PATH="\${TF_VAR_env_prefix}_generated_key.pem"

# =============================================================================
# SSH ALIASES (Optimizations 2, 8)
# =============================================================================

# Wait for SSH (enhanced with multi-instance support)
alias lw='wait_for_ssh \${TF_VAR_region} \${TF_VAR_env_prefix}'
alias lw1='wait_for_ssh \${TF_VAR_region} \${TF_VAR_env_prefix} 1'
alias lw2='wait_for_ssh \${TF_VAR_region} \${TF_VAR_env_prefix} 2'

# SSH with gpadmin setup (fixed consistency issue)
alias lgw='wait_for_ssh \${TF_VAR_region} \${TF_VAR_env_prefix}; \\
           ssh "\${SSH_OPTS[@]}" \\
               -i \${SSH_KEY_PATH} \\
               \${TF_VAR_default_username}@\$(get_instance_ip 0) \\
               "cat ~/.ssh/authorized_keys | sudo tee -a ~gpadmin/.ssh/authorized_keys" && \\
           echo "✅ SSH key copied to gpadmin user"'

# SSH connections (using cached IPs and timeouts)
alias lssh='ssh "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} \${TF_VAR_default_username}@\$(get_instance_ip 0) -A'
alias lssh1='ssh "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} \${TF_VAR_default_username}@\$(get_instance_ip 1) -A'
alias lssh2='ssh "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} \${TF_VAR_default_username}@\$(get_instance_ip 2) -A'

alias lgssh='ssh "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} gpadmin@\$(get_instance_ip 0) -A'
alias lgssh1='ssh "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} gpadmin@\$(get_instance_ip 1) -A'
alias lgssh2='ssh "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} gpadmin@\$(get_instance_ip 2) -A'

# =============================================================================
# INSTANCE MANAGEMENT (Optimization 3)
# =============================================================================

# Instance state with enhanced output (excluding terminated instances)
alias istate='aws ec2 describe-instances --region "\$TF_VAR_region" \\
  --filters "Name=tag:Name,Values=\${TF_VAR_env_prefix}-instance-*" \\
            "Name=instance-state-name,Values=pending,running,shutting-down,stopping,stopped" \\
  --query "Reservations[].Instances[].[Tags[?Key==\\\`Name\\\`].Value|[0], State.Name, InstanceType, PublicIpAddress, PrivateIpAddress]" \\
  --output table'

# All non-terminated instances across the project
alias iastate='aws ec2 describe-instances --region "\$TF_VAR_region" \\
  --filters "Name=instance-state-name,Values=pending,running,shutting-down,stopping,stopped" \\
  --query "Reservations[].Instances[].[Tags[?Key==\\\`Name\\\`].Value|[0], State.Name, InstanceType, PublicIpAddress, PrivateIpAddress]" \\
  --output table'

# Instance start with cache invalidation
alias istart='echo "🚀 Starting instances..." && \\
  STOPPED_IDS=\$(aws ec2 describe-instances --region "\$TF_VAR_region" \\
    --filters "Name=tag:Name,Values=\${TF_VAR_env_prefix}-instance-*" "Name=instance-state-name,Values=stopped" \\
    --query "Reservations[].Instances[].InstanceId" --output text) && \\
  if [[ -n "\$STOPPED_IDS" ]]; then \\
    aws ec2 start-instances --region "\$TF_VAR_region" --instance-ids \$STOPPED_IDS && \\
    echo "⏳ Waiting for instances to be running..." && \\
    aws ec2 wait instance-running --region "\$TF_VAR_region" --instance-ids \$STOPPED_IDS && \\
    echo "✅ Instances are now running"; \\
  else \\
    echo "ℹ️  No stopped instances found to start"; \\
  fi; \\
  clean_ip_cache'

# Instance stop with cache invalidation
alias istop='echo "🛑 Stopping instances..." && \\
  RUNNING_IDS=\$(aws ec2 describe-instances --region "\$TF_VAR_region" \\
    --filters "Name=tag:Name,Values=\${TF_VAR_env_prefix}-instance-*" "Name=instance-state-name,Values=running" \\
    --query "Reservations[].Instances[].InstanceId" --output text) && \\
  if [[ -n "\$RUNNING_IDS" ]]; then \\
    aws ec2 stop-instances --region "\$TF_VAR_region" --no-hibernate --instance-ids \$RUNNING_IDS && \\
    echo "⏳ Waiting for instances to stop..." && \\
    aws ec2 wait instance-stopped --region "\$TF_VAR_region" --instance-ids \$RUNNING_IDS && \\
    echo "✅ Instances are now stopped"; \\
  else \\
    echo "ℹ️  No running instances found to stop"; \\
  fi; \\
  clean_ip_cache'

# Refresh with cache invalidation
alias irefresh='clean_ip_cache && echo "✅ IP cache refreshed"'

# =============================================================================
# FILE TRANSFER (Optimization 6)
# =============================================================================

# Enhanced SCP aliases with progress feedback
alias lcopyto='function _lcopyto() { 
  echo "📤 Copying \$1 to \${TF_VAR_default_username}@\$(get_instance_ip 0):\$2"
  scp "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} "\$1" \${TF_VAR_default_username}@\$(get_instance_ip 0):"\$2"
}; _lcopyto'

alias lgcopyto='function _lgcopyto() { 
  echo "📤 Copying \$1 to gpadmin@\$(get_instance_ip 0):\$2"
  scp "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} "\$1" gpadmin@\$(get_instance_ip 0):"\$2"
}; _lgcopyto'

alias lcopyfrom='function _lcopyfrom() { 
  echo "📥 Copying \${TF_VAR_default_username}@\$(get_instance_ip 0):\$1 to \$2"
  scp "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} \${TF_VAR_default_username}@\$(get_instance_ip 0):"\$1" "\$2"
}; _lcopyfrom'

alias lgcopyfrom='function _lgcopyfrom() { 
  echo "📥 Copying gpadmin@\$(get_instance_ip 0):\$1 to \$2"
  scp "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} gpadmin@\$(get_instance_ip 0):"\$1" "\$2"
}; _lgcopyfrom'

# Multi-instance SCP
alias lcopyto1='function _lcopyto1() { 
  echo "📤 Copying \$1 to \${TF_VAR_default_username}@\$(get_instance_ip 1):\$2"
  scp "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} "\$1" \${TF_VAR_default_username}@\$(get_instance_ip 1):"\$2"
}; _lcopyto1'

alias lcopyto2='function _lcopyto2() { 
  echo "📤 Copying \$1 to \${TF_VAR_default_username}@\$(get_instance_ip 2):\$2"
  scp "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} "\$1" \${TF_VAR_default_username}@\$(get_instance_ip 2):"\$2"
}; _lcopyto2'

# =============================================================================
# STATUS & MONITORING (Optimization 5)
# =============================================================================

# Status and monitoring shortcuts
alias istatus='echo "📊 \${TF_VAR_env_prefix} Status:" && istate'

alias iping='for i in {0..2}; do 
  echo "🏓 Pinging instance-\$i:"
  timeout 3 ping -c 2 \$(get_instance_ip \$i) 2>/dev/null || echo "❌ Instance \$i not reachable"
done'

alias ilogs='ssh "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} gpadmin@\$(get_instance_ip 0) "sudo journalctl -f"'

alias itop='ssh "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} gpadmin@\$(get_instance_ip 0) "htop"'

alias idisk='ssh "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} gpadmin@\$(get_instance_ip 0) "df -h && echo && lsblk"'

# =============================================================================
# VS CODE & DEVELOPMENT
# =============================================================================

# Enhanced VS Code remote with error handling
alias icode='function _icode() {
  local path="\${1:-/home/gpadmin}"
  local hostname=\$(get_instance_ip 0)
  if [[ -n "\$hostname" && "\$hostname" != "None" ]]; then
    echo "🔗 Opening VS Code remote to \${hostname}:\${path}"
    /Applications/Visual\\ Studio\\ Code.app/Contents/Resources/app/bin/code --remote "ssh-remote+\${TF_VAR_env_prefix}" "\$path"
  else 
    echo "❌ Cannot connect - instance not running"
    return 1
  fi
}; _icode'

alias icloudberry='icode /home/gpadmin/cloudberry'

# =============================================================================
# UTILITY ALIASES
# =============================================================================

# Network and AWS utilities
alias myip='echo \$(curl -s https://api.ipify.org)'
alias isso='aws sso login --sso-session your-sso-session'

# Spot instance availability checker aliases
alias spot-check='check_spot_availability'
alias spot-prices='check_spot_prices'

# Justfile integration (update path as needed)
alias j='just -f /home/gpadmin/cloudberry-devenv-launcher/docs/Justfile'

# Performance testing
alias itest='echo "🧪 Running performance tests..." && ./performance-test.sh'

# Environment info
alias iinfo='echo "🏷️  Environment: \$TF_VAR_env_prefix" && 
echo "🌍 Region: \$TF_VAR_region" && 
echo "👤 User: \$TF_VAR_default_username" && 
echo "🆔 AMI: \$TF_VAR_ami" && 
echo "💻 Instance Type: \$TF_VAR_instance_type" && 
echo "🔢 VM Count: \$TF_VAR_vm_count"'

# OS version check
unalias ios 2>/dev/null || true
ios() {
    ssh "\${SSH_OPTS[@]}" -i \${SSH_KEY_PATH} \${TF_VAR_default_username}@\$(get_instance_ip 0) 'if [ -f /etc/os-release ]; then source /etc/os-release && echo \$PRETTY_NAME; else cat /proc/version | sed "s/Linux version //" | cut -d" " -f1-2; fi' 2>/dev/null
}

# Terraform init aliases
alias ti='terraform init'      # Local backend (uses backend.tf config)
EOF
    
    # No need to modify main.tf - template now uses generic names
    
    echo -e "${GREEN}✨ Environment created successfully!${NC}"
    echo
    echo -e "${YELLOW}📁 Location:${NC} $target_dir"
    echo -e "${YELLOW}🔧 Next steps:${NC}"
    echo -e "  1. ${CYAN}cd $target_dir${NC}"
    echo -e "  2. ${CYAN}direnv allow .${NC}"
    echo -e "  3. ${CYAN}terraform init${NC}"
    echo -e "  4. ${CYAN}terraform plan${NC}"
    echo -e "  5. ${CYAN}terraform apply${NC}"
    echo
}

# Function to get OS selection
get_os_selection() {
    while true; do
        show_options
        
        local max_choice=${#SELECTION_MAP[@]}
        echo -n -e "${YELLOW}Select an OS [1-${max_choice}] or 'q' to quit: ${NC}"
        read -r selection
        
        # Check for quit
        if [[ "$selection" == "q" || "$selection" == "Q" ]]; then
            echo -e "${YELLOW}👋 Goodbye!${NC}"
            exit 0
        fi
        
        # Validate selection
        if validate_selection "$selection"; then
            return 0
        fi
        
        echo
        echo -e "${RED}❌ Invalid selection. Please try again.${NC}"
        echo
    done
}

# Function to get directory name choice
get_directory_name() {
    local selection=$1
    local actual_key="${SELECTION_MAP[$selection]}"
    local custom_name=""
    
    while true; do
        echo -e "${YELLOW}Directory name options:${NC}"
        echo -e "  ${GREEN}[1]${NC} Use default name: ${CYAN}${DIR_NAMES[$actual_key]}${NC} ${PURPLE}(default)${NC}"
        echo -e "  ${GREEN}[2]${NC} Enter custom name"
        echo -e "  ${GREEN}[b]${NC} Back to OS selection"
        echo
        echo -n -e "${YELLOW}Choose option [1/2/b] (default: 1): ${NC}"
        read -r name_choice
        
        # Default to option 1 if empty
        if [[ -z "$name_choice" ]]; then
            name_choice="1"
        fi
        
        case "$name_choice" in
            "1")
                custom_name=""
                break
                ;;
            "2")
                echo -n -e "${YELLOW}Enter custom directory name: ${NC}"
                read -r custom_name
                if [[ -z "$custom_name" ]]; then
                    echo -e "${RED}❌ Empty name not allowed${NC}"
                    echo
                    continue
                fi
                # Validate directory name (basic check)
                if [[ ! "$custom_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
                    echo -e "${RED}❌ Invalid directory name. Use only letters, numbers, hyphens, and underscores.${NC}"
                    echo
                    continue
                fi
                break
                ;;
            "b"|"B")
                return 1  # Signal to go back
                ;;
            *)
                echo -e "${RED}❌ Invalid option. Please choose 1, 2, or b.${NC}"
                echo
                ;;
        esac
    done
    
    # Return the custom name via a global variable
    SELECTED_CUSTOM_NAME="$custom_name"
    return 0
}

# Function to confirm environment creation
confirm_creation() {
    local selection=$1
    local custom_name="$2"
    local actual_key="${SELECTION_MAP[$selection]}"
    local os_name="${OS_OPTIONS[$actual_key]}"
    local dir_name="${custom_name:-${DIR_NAMES[$actual_key]}}"
    
    while true; do
        echo
        echo -e "${CYAN}📋 Summary:${NC}"
        echo -e "  ${PURPLE}OS:${NC} $os_name"
        echo -e "  ${PURPLE}Directory:${NC} $dir_name"
        echo -e "  ${PURPLE}AMI Owner:${NC} ${AMI_OWNERS[$actual_key]}"
        echo -e "  ${PURPLE}AMI Filter:${NC} ${AMI_FILTERS[$actual_key]}"
        echo -e "  ${PURPLE}Username:${NC} ${DEFAULT_USERNAMES[$actual_key]}"
        echo
        echo -e "${YELLOW}Actions:${NC}"
        echo -e "  ${GREEN}[c]${NC} Create environment ${PURPLE}(default)${NC}"
        echo -e "  ${GREEN}[b]${NC} Back to directory name"
        echo -e "  ${GREEN}[o]${NC} Back to OS selection"
        echo -e "  ${GREEN}[q]${NC} Quit"
        echo
        echo -n -e "${YELLOW}Choose action [c/b/o/q] (default: c): ${NC}"
        read -r action
        
        # Default to create if empty
        if [[ -z "$action" ]]; then
            action="c"
        fi
        
        case "$action" in
            "c"|"C")
                return 0  # Proceed with creation
                ;;
            "b"|"B")
                return 1  # Go back to directory name
                ;;
            "o"|"O")
                return 2  # Go back to OS selection
                ;;
            "q"|"Q")
                echo -e "${YELLOW}👋 Goodbye!${NC}"
                exit 0
                ;;
            *)
                echo -e "${RED}❌ Invalid option. Please choose c, b, o, or q.${NC}"
                echo
                ;;
        esac
    done
}

# Main function with navigation flow
main() {
    check_template
    show_header
    
    while true; do
        # Step 1: Get OS selection
        get_os_selection
        local selection=$selection
        
        while true; do
            # Show configuration for selected OS
            show_configuration "$selection"
            
            # Step 2: Get directory name
            if get_directory_name "$selection"; then
                local custom_name="$SELECTED_CUSTOM_NAME"
                
                # Step 3: Confirm and create
                local confirm_result
                confirm_creation "$selection" "$custom_name"
                confirm_result=$?
                
                case $confirm_result in
                    0)
                        # Create environment and exit
                        create_environment "$selection" "$custom_name"
                        exit 0
                        ;;
                    1)
                        # Go back to directory name - continue inner loop
                        continue
                        ;;
                    2)
                        # Go back to OS selection - break inner loop
                        break
                        ;;
                esac
            else
                # User chose to go back to OS selection
                break
            fi
        done
    done
}

# Run main function
main "$@"